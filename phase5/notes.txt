memcpy causes the page fault when vmregion isn't mapped. pager kicks in:
checks what interrupt says (what page was it?) Do I have an empty frame? Map it.
child is blocked in the meantime by pager through the interrupt handler.
 when things are mapped, pager wakes child, child will try memcpy again.

p1_fork
malloc the page table for the process
need a way for p1.c to figure out if vminit was called (and thus virtual mem applies to that proc)
-debug print stmt helps

p1_quit
unmaps the mappings
make the spot on the disk available to use

zero out the frame before you use it
ask if its in mem
ask if its on disk

proc a gets frame 3
say another process b comes along, all frames are taken.
pick a frame, say frame 3, put it on disk (remember where you put it), zero it, give it to that processes
later proc a tries to access that frame 3, looks in its page table (no frame is assigned)
    -but it's on disk. find a frame (zero it too), get the data back by reading
    from disk and put it into that frame. map it, and give that frame to proc a
